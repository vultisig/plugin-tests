// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: test_runs.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTestRuns = `-- name: CountTestRuns :one
SELECT COUNT(*)::bigint FROM test_runs
WHERE ($1::text IS NULL OR plugin_id = $1)
  AND ($2::test_run_status IS NULL OR status = $2)
`

type CountTestRunsParams struct {
	PluginID pgtype.Text       `json:"plugin_id"`
	Status   NullTestRunStatus `json:"status"`
}

func (q *Queries) CountTestRuns(ctx context.Context, arg *CountTestRunsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTestRuns, arg.PluginID, arg.Status)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createTestRun = `-- name: CreateTestRun :one
INSERT INTO test_runs (plugin_id, proposal_id, version, status, requested_by)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, plugin_id, proposal_id, version, status, requested_by, artifact_prefix, error_message, started_at, finished_at, created_at, updated_at
`

type CreateTestRunParams struct {
	PluginID    string        `json:"plugin_id"`
	ProposalID  pgtype.Text   `json:"proposal_id"`
	Version     pgtype.Text   `json:"version"`
	Status      TestRunStatus `json:"status"`
	RequestedBy string        `json:"requested_by"`
}

func (q *Queries) CreateTestRun(ctx context.Context, arg *CreateTestRunParams) (*TestRun, error) {
	row := q.db.QueryRow(ctx, createTestRun,
		arg.PluginID,
		arg.ProposalID,
		arg.Version,
		arg.Status,
		arg.RequestedBy,
	)
	var i TestRun
	err := row.Scan(
		&i.ID,
		&i.PluginID,
		&i.ProposalID,
		&i.Version,
		&i.Status,
		&i.RequestedBy,
		&i.ArtifactPrefix,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getDistinctPluginIDs = `-- name: GetDistinctPluginIDs :many
SELECT DISTINCT plugin_id FROM test_runs ORDER BY plugin_id
`

func (q *Queries) GetDistinctPluginIDs(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getDistinctPluginIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var plugin_id string
		if err := rows.Scan(&plugin_id); err != nil {
			return nil, err
		}
		items = append(items, plugin_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStaleRunningRuns = `-- name: GetStaleRunningRuns :many
SELECT id, plugin_id, proposal_id, version, status, requested_by, artifact_prefix, error_message, started_at, finished_at, created_at, updated_at FROM test_runs
WHERE status = 'RUNNING' AND started_at < NOW() - $1::interval
`

func (q *Queries) GetStaleRunningRuns(ctx context.Context, dollar_1 pgtype.Interval) ([]*TestRun, error) {
	rows, err := q.db.Query(ctx, getStaleRunningRuns, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TestRun{}
	for rows.Next() {
		var i TestRun
		if err := rows.Scan(
			&i.ID,
			&i.PluginID,
			&i.ProposalID,
			&i.Version,
			&i.Status,
			&i.RequestedBy,
			&i.ArtifactPrefix,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.FinishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestRun = `-- name: GetTestRun :one
SELECT id, plugin_id, proposal_id, version, status, requested_by, artifact_prefix, error_message, started_at, finished_at, created_at, updated_at FROM test_runs
WHERE id = $1
`

func (q *Queries) GetTestRun(ctx context.Context, id pgtype.UUID) (*TestRun, error) {
	row := q.db.QueryRow(ctx, getTestRun, id)
	var i TestRun
	err := row.Scan(
		&i.ID,
		&i.PluginID,
		&i.ProposalID,
		&i.Version,
		&i.Status,
		&i.RequestedBy,
		&i.ArtifactPrefix,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listTestRuns = `-- name: ListTestRuns :many
SELECT id, plugin_id, proposal_id, version, status, requested_by, artifact_prefix, error_message, started_at, finished_at, created_at, updated_at FROM test_runs
WHERE ($1::text IS NULL OR plugin_id = $1)
  AND ($2::test_run_status IS NULL OR status = $2)
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

type ListTestRunsParams struct {
	PluginID    pgtype.Text       `json:"plugin_id"`
	Status      NullTestRunStatus `json:"status"`
	QueryOffset int32             `json:"query_offset"`
	QueryLimit  int32             `json:"query_limit"`
}

func (q *Queries) ListTestRuns(ctx context.Context, arg *ListTestRunsParams) ([]*TestRun, error) {
	rows, err := q.db.Query(ctx, listTestRuns,
		arg.PluginID,
		arg.Status,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TestRun{}
	for rows.Next() {
		var i TestRun
		if err := rows.Scan(
			&i.ID,
			&i.PluginID,
			&i.ProposalID,
			&i.Version,
			&i.Status,
			&i.RequestedBy,
			&i.ArtifactPrefix,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.FinishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markStaleRunAsError = `-- name: MarkStaleRunAsError :exec
UPDATE test_runs
SET status = 'ERROR', error_message = $2, finished_at = NOW(), updated_at = NOW()
WHERE id = $1 AND status = 'RUNNING'
`

type MarkStaleRunAsErrorParams struct {
	ID           pgtype.UUID `json:"id"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) MarkStaleRunAsError(ctx context.Context, arg *MarkStaleRunAsErrorParams) error {
	_, err := q.db.Exec(ctx, markStaleRunAsError, arg.ID, arg.ErrorMessage)
	return err
}

const updateTestRunFinished = `-- name: UpdateTestRunFinished :exec
UPDATE test_runs
SET status = $2, artifact_prefix = $3, error_message = $4, finished_at = NOW(), updated_at = NOW()
WHERE id = $1
`

type UpdateTestRunFinishedParams struct {
	ID             pgtype.UUID   `json:"id"`
	Status         TestRunStatus `json:"status"`
	ArtifactPrefix pgtype.Text   `json:"artifact_prefix"`
	ErrorMessage   pgtype.Text   `json:"error_message"`
}

func (q *Queries) UpdateTestRunFinished(ctx context.Context, arg *UpdateTestRunFinishedParams) error {
	_, err := q.db.Exec(ctx, updateTestRunFinished,
		arg.ID,
		arg.Status,
		arg.ArtifactPrefix,
		arg.ErrorMessage,
	)
	return err
}

const updateTestRunStarted = `-- name: UpdateTestRunStarted :exec
UPDATE test_runs
SET status = 'RUNNING', started_at = NOW(), updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateTestRunStarted(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateTestRunStarted, id)
	return err
}
