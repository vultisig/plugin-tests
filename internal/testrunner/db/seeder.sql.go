// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: seeder.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const upsertPlugin = `-- name: UpsertPlugin :exec
INSERT INTO plugins (id, title, description, server_endpoint, category, audited)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (id) DO UPDATE SET
    title = EXCLUDED.title,
    description = EXCLUDED.description,
    server_endpoint = EXCLUDED.server_endpoint,
    category = EXCLUDED.category,
    audited = EXCLUDED.audited,
    updated_at = NOW()
`

type UpsertPluginParams struct {
	ID             interface{}
	Title          string
	Description    string
	ServerEndpoint string
	Category       PluginCategory
	Audited        bool
}

func (q *Queries) UpsertPlugin(ctx context.Context, arg *UpsertPluginParams) error {
	_, err := q.db.Exec(ctx, upsertPlugin,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.ServerEndpoint,
		arg.Category,
		arg.Audited,
	)
	return err
}

const upsertPluginAPIKey = `-- name: UpsertPluginAPIKey :exec
INSERT INTO plugin_apikey (id, plugin_id, apikey, created_at, expires_at, status)
VALUES (gen_random_uuid(), $1, $2, NOW(), NULL, 1)
ON CONFLICT DO NOTHING
`

type UpsertPluginAPIKeyParams struct {
	PluginID interface{}
	Apikey   string
}

func (q *Queries) UpsertPluginAPIKey(ctx context.Context, arg *UpsertPluginAPIKeyParams) error {
	_, err := q.db.Exec(ctx, upsertPluginAPIKey, arg.PluginID, arg.Apikey)
	return err
}

const upsertPluginPolicy = `-- name: UpsertPluginPolicy :exec
INSERT INTO plugin_policies (id, public_key, plugin_id, plugin_version, policy_version, signature, recipe, active)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (id) DO UPDATE SET
    public_key = EXCLUDED.public_key,
    plugin_id = EXCLUDED.plugin_id,
    plugin_version = EXCLUDED.plugin_version,
    policy_version = EXCLUDED.policy_version,
    signature = EXCLUDED.signature,
    recipe = EXCLUDED.recipe,
    active = EXCLUDED.active,
    updated_at = NOW()
`

type UpsertPluginPolicyParams struct {
	ID            pgtype.UUID
	PublicKey     string
	PluginID      interface{}
	PluginVersion string
	PolicyVersion int32
	Signature     string
	Recipe        string
	Active        bool
}

func (q *Queries) UpsertPluginPolicy(ctx context.Context, arg *UpsertPluginPolicyParams) error {
	_, err := q.db.Exec(ctx, upsertPluginPolicy,
		arg.ID,
		arg.PublicKey,
		arg.PluginID,
		arg.PluginVersion,
		arg.PolicyVersion,
		arg.Signature,
		arg.Recipe,
		arg.Active,
	)
	return err
}

const upsertVaultToken = `-- name: UpsertVaultToken :exec
INSERT INTO vault_tokens (token_id, public_key, expires_at, last_used_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (token_id) DO UPDATE SET
    public_key = EXCLUDED.public_key,
    expires_at = EXCLUDED.expires_at,
    last_used_at = EXCLUDED.last_used_at,
    revoked_at = NULL,
    updated_at = NOW()
`

type UpsertVaultTokenParams struct {
	TokenID    string
	PublicKey  string
	ExpiresAt  pgtype.Timestamptz
	LastUsedAt pgtype.Timestamptz
}

func (q *Queries) UpsertVaultToken(ctx context.Context, arg *UpsertVaultTokenParams) error {
	_, err := q.db.Exec(ctx, upsertVaultToken,
		arg.TokenID,
		arg.PublicKey,
		arg.ExpiresAt,
		arg.LastUsedAt,
	)
	return err
}
